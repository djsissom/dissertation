
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Numerical Methods
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Chapter Introduction
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


In this chapter, we discuss the computational tools used in this study.  While Section~\ref{sec:computational_theory} dealt with the underlying principles behind some of the numerical methods used here, this section will instead focus on the actual implementation details of the code, as well as how each piece is incorporated into the analysis pipeline.  The content proceeds in a natural order, following the flow of data.  We begin with generation of simulation initial conditions according to \za\ and \lpt, followed by a discussion of \gadgettwo\ and our specific simulations, halo finding with \rockstar, and pairing companion halos between simulations with \crossmatch.  We then present the tools created for analysis of the data, and conclude with a discussion of the automation steps and scripts used to tie each component together.  We additionally present example plots obtained from some of the analysis steps in order to demonstrate the function of each code.  However, we defer discussion of the actual results presented in these plots until Chapter~\ref{chap:2lpt}, where they are given full treatment.  The code referenced in this section that was specifically created for this project is reproduced in the Appendices.




